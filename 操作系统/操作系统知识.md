

## Linux命令

1. ps

1. 

## 什么是进程、线程、协程、管程？

进程：运行中的程序

线程：进程内部的一条执行序列，一个线程包含了多条线程

协程：轻量级线程，在子程序内部使用，可以在子程序内部中断，转而执行别的子程序，在适当的时候再返回来继续执行

## 进程之间的通信（IPC，Inter-Process Communication）

### 1.通信方式

### 1.管道

管道是一种两个进程间行单向通信的机制，分为无名管道和命名管道。

* 管道是半全工通信，数据只能单向流动，一个进程B向写管道写数据，另一个进程A从读管道读数据
* 管道是先进先出的，写入的数据每次添加到管道缓冲区的末尾，读数据的时候从缓冲区的头部读取
* 管道本质是一种缓存，都是使用文件描述符以文件的形式操作的



#### 1）匿名管道

* 匿名管道只能在具有亲缘关系的进程间通信，如父子关系。
* 匿名管道开辟的管道没有文件名，所以必须要通过继承方式才能获取文件描述符
* ❗注意：**如果读管道时没有数据，读操作将会阻塞**

> 当管道的读端都关闭了，内核会向写数据的进程发送SIGPIPE信号，终止进程



```c
int pipe(int pipefd[2]);//创建管道函数
```

pipedfd数组存储的是进程的文件描述符，pipedfd[0]为读管道，pipedfd[1]为写管道



**流程**：

1. 父进程调用pipe函数，并传入数组pipefd,
2. 父进程fork一个子进程，子进程继承了数组pipedfd
3. 父进程关闭pipefd[0],即读管道，子进程关闭pipefd[1],即写管道，父进程可以向管道写入数据，子进程从管道读取数据。实现了进程间的通信



```c
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<strings.h>

int main(void)
{
	int result = 0;
	int pipefd[2] = {0};//用于存放管道的读写文件描述符

	result = pipe(pipefd);
	if(result==-1) printf("pipe fail");

	printf("0: %d,1: %d\n",pipefd[0],pipefd[1]);
	
	result = fork();//创建子进程
	if(result > 0)//返回进程id表示为父进程
	{
		while(1)
		{
		write(pipefd[0],"hello",5);
		sleep(1);
		}
	}
	else if(result ==0)//返回0表示当前为子进程
	{
		while(1)
		{
			char buf[30] = {0};
			bzero(buf,sizeof(buf));//清空缓存
			read(pipefd[0],buf,sizeof(buf));
			printf("child,data:%s\n",buf);
		}
	}
	return 0;
}

```

#### 2）命名管道

> 匿名管道由于没有名字，只能用于亲缘关系的进程间通信，如父子进程和兄弟进程
>
> 为了克服这个缺点，提出了有名管道（FIFO）

* 进程可以通过open函数打开管道文件，从而获取文件描述符，可以用于任意两个进程之间通信
* 读管道时，如果管道没有数据会阻塞
* 当管道的读端都关闭了，内核会向写数据的进程发送SIGPIPE信号，终止进程

**流程**：

1. 进程调用mkfifo创建有名管道
2. 调用open函数打开有名管道
3. 使用read/write读写管道进行通信



```c
# include<sys/types.h>
# include<sys/stat.h>
int mkfifo(const char * pathname, mode_t mode);
//pathname 被创建管道的管道文件名
//mode  指定被创建时的原始权限，必须包含读写权限
```

### 2.信号

 信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。也可以简单理解为信号是某种形式上的软中断。

1. 一般情况下，信号的来源可分为以下三种：

- 硬件方式：除数为零、无效的存储访问等硬件异常产生信号。这些事件通常由硬件(如:CPU)检测到，并将其通知给Linux操作系统内核，然后内核生成相应的信号，并把信号发送给该事件发生时正在进行的程序。

- 软件方式：用户在终端下调用`kill`命令向进程发送任务信号、进程调用`kill`或`sigqueue`函数发送信号、当检测到某种软件条件已经具备时发出信号，如由`alarm`或`settimer`设置的定时器超时时将生成`SIGALRM`信号等多种情景均可产生信号。

- 键盘输入：当用户在终端上按下某键时，将产生信号。如按下组合键`Ctrl+C`将产生一个`SIGINT`信号，`Ctrl+\`产生一个`SIGQUIT`信号等。

  以下列出几个常用的信号：

|  信号   |                             描述                             |
| :-----: | :----------------------------------------------------------: |
| SIGHUP  | 当用户退出终端时，由该终端开启的所有进程都退接收到这个信号，默认动作为终止进程。 |
| SIGINT  | 程序终止(interrupt)信号, 在用户键入INTR字符(通常是`Ctrl+C`)时发出，用于通知前台进程组终止进程。 |
| SIGQUIT | 和`SIGINT`类似, 但由QUIT字符(通常是`Ctrl+\`)来控制. 进程在因收到`SIGQUIT`退出时会产生`core`文件, 在这个意义上类似于一个程序错误信号。 |
| SIGKILL |  用来立即结束程序的运行. **本信号不能被阻塞、处理和忽略**。  |
| SIGTERM | 程序结束(terminate)信号, 与`SIGKILL`不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。 |
| SIGSTOP | 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行. **本信号不能被阻塞, 处理或忽略**. |

### 3.消息队列

> 通过ipcs命令可以查看System V ipc情况

![image-20210406143425316](C:\Environment\Github\Typora\操作系统\image-20210406143425316.png)

* 消息队列是**存放在内核中的消息链表**，每个消息队列由消息队列标识符表示。
* 消息队列存在内核中，只有内核重启或显式删除才会删除

![image-20210406142046235](C:\Environment\Github\Typora\操作系统\image-20210406142046235.png)

从图可知：消息由两部分组成，分别为消息编号和消息正文



### 4.共享内存

进程间本身的内存是相互隔离的，而共享内存机制相当于给两个进程开辟了一块二者均可访问的内存空间，这时，两个进程便可以共享一些数据了。

### 5.信号量

信号量主要用来解决进程和线程间并发执行时的同步问题，进程同步是并发进程为了完成共同任务采用某个条件来协调他们的活动，这是进程之间发生的一种直接制约关系。

对信号量的操作分为P操作和V操作，P操作是将信号量的值减一，V操作是将信号量的值加一。当信号量的值小于等于0之后，再进行P操作时，当前进程或线程会被阻塞，直到另一个进程或线程执行了V操作将信号量的值增加到大于0之时。锁也是用的这种原理实现的。

信号量我们需要定义信号量的数量，设定初始值，以及决定何时进行PV操作。

### 6.socket

不同主机之间的进程进行双向通信的端点

## 僵尸进程和孤儿进程

> 我们知道在unix/linux中，正常情况下，子进程是通过父进程创建的，子进程在创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个 进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。

孤儿进程：一个父进程退出杀死，而其子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将由init进程完成状态收集工作。

僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程没有调用wati或waitpid获取子进程的状态信息，那么子进程的进程描述符仍保留在系统中。

## 什么情况下会发生死锁？

> 如果在计算机系统中同时具备以下四个条件，那么会发生死锁

1. 互斥条件

资源在一段时间内只能由一个进程占有，不能同时由两个以上的进程占有。

2. 不可剥夺条件

申请资源的进程不能从占有资源的进程中夺取资源，只能由占有者自行释放

3. 请求和保持条件

进程占有了一个资源，又申请新的资源，由于该资源被另外的进程占有，此时该进程阻塞，同时另外的进程也申请该进程占有的资源，

4. 循环等待条件

两个进程互相申请对方占有的资源，互相都阻塞。形成一个进程循环等待环

## 用户态和内核态



## 说说你对自旋锁的理解

> 当一个线程尝试获取一把锁时，如果已经被其他线程占有。那么线程无法获取，那么线程会等待，间隔一段时间后会再次尝试获取。这种循环尝试获取锁的机制称为自旋锁

### 特点

* 用于临界互斥
* 在任何时刻最多只能有一个执行单元获得锁
* 等待锁的线程会进入慢循环

### 缺点

* 如果线程占有锁时间很长，会导致需要获取该锁的线程进入循环等待，不断尝试获取锁，消耗CPU
* 如果该锁是非公平锁，那等待时间最长的锁不能优先获取锁，存在`线程饥饿`的问题

### 优点

* 自旋锁不会使线程状态发生切换，一直处于用户态。不会使锁进入阻塞状态，减少了不必要的上下文切换，

  

## 说一说乐观锁和悲观锁

1. 乐观锁总是假设最好的情况，每次拿数据都认为不会有别人修改，所以不上锁。

2. 悲观锁总是假设最坏的情况，每次去拿数据都认为别人会修改数据，所以每次拿数据都会上锁。

## 说说CAS

CAS是CompareAndSwap的所需，比较并替换。CAS操作需要有三个操作数，即内存地址，旧的内存地址，即将要更新的值。当且仅当内存地址与旧的预期地址相同时，才会将内存地址改为要更新的值。CAS是一个原子操作



## IO多路复用

> 前提掌握文件描述符、文件句柄

### 1.文件描述符fd和文件句柄

操作系统为每一个进程维护了一个文件表，文件表的每一项包含了文件描述符和文件指针，指向具体的文件句柄

在Linux系统中，当一个进程请求内核打开/新建一个文件时，内核会返回一个`文件描述符`fd 对应这个文件，fd是一个非负整数

每一个进程能够打开的文件句柄有限制

```shell
#查看允许打开的最大文件句柄数
ulimit -n
```

![img](C:\Environment\Github\Typora\操作系统\5362354-dd7d2767fb6de9bb.png)



IO多路复用是一种同步IO模型，可以实现一个线程监听多个文件句柄，一旦文件句柄就绪，就可以通知应用程序进行相应的读写操作

> 复用指同一个线程，多路指网络连接。

### 2. 5种I/O模型

* 阻塞IO

> 当发起一次操作后，一直等待成功或失败后才返回，这期间程序不能做其他事情。阻塞IO只能对单个文件描述符操作

* 非阻塞IO

> 发起IO时，通过对文件描述符设置O_NONBLOCK flag来指定其IO操作为非阻塞，当IO操作会阻塞是会返回错误，然后轮询调用

* IO多路复用

典型应用：Java NIO；

* 信号驱动IO

当进程发起一个IO操作时，会向内核注册一个信号处理函数，然后进程返回不阻塞，当内核数据就绪时，向进程发送信号，进程便在信号处理函数中调用IO读取数据

* 异步IO

和信号驱动IO差不多，当进程发起一个IO操作，进程返回，当内核数据就绪时，异步IO完成了数据拷贝再通知进程，而不需要进程在程序中处理。

典型应用：Java AIO



### 3.IO多路复用有三种实现方式：select,poll,epoll

1. select         时间复杂度O(n)

select线程仅仅知道有IO时间发生了，但是不知道是哪几个流，只能无差别轮询所有的流，找出能读数据和写数据的流进行操作。



2. poll  时间复杂度O(n)

poll本质和select没有区别



3. epoll  时间复杂度O(1)

epoll可以理解为event poll。epoll会把具体哪个流发生了什么IO时间通知我们

