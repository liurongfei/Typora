

## 一.运行时数据区域



 虚拟机运行时的数据区

![image-20210407115126325](C:\Environment\Github\Typora\Java虚拟机\image-20210407115126325.png)



### 1.程序计数器

多线程是通过线程轮回切换、分配cpu执行时间来实现的，为了线程切换后能够恢复到正确的执行位置，每一个线程都需要一个程序计数器，各线程之间计数器互不影响，独立存储。

### 2.Java虚拟机栈

* 每一个Java方法执行时，jvm都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。

* 方法调用时，栈帧从Java虚拟机栈入栈，方法执行完毕，栈帧从Java虚拟机栈出栈。

* Java虚拟机栈也是线程私有的，它的生命周期与线程相同。



局部变量表：



### 3.本地方法栈

本地方法栈的作用与Java虚拟机栈的作用相似，区别是本地方法栈是为使用的native方法服务

### 4.Java堆

Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建，存放对象实例。

### 5.方法区

> 别名，非堆（Non-Heap），目的是与Java堆区分开来

方法区与Java堆一样，是各个线程共享的内存区域。用于存储已被虚拟机加载的类型信息，如类名、访问修饰符、常量池、字段描述、方法描述等。



### 6.运行时常量池

运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量与符号引用。

### 7.直接内存

直接内存不是虚拟机运行时数据区的一部分。

NIO类可以使用Native函数库直接分配堆外内存。

## 二、对象内存布局

以HotSpot虚拟机为例，对象在堆内存的布局分为三部分：对象头、实例数据和对齐填充

* 对象头：包含两部分，Mark Word和Klass Point。
  * Mark Word存储对象自身运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳等。
  * 类型指针指向对象的类型元数据，用于jvm确认对象是哪个类的实例
* 实例数据：对象存储的有效信息，即在程序代码中定义的各种类型的字段内容
* 对齐填充：没有特别的含义，用于将对象的大小保持为8字节的整数倍

![image-20210407163119673](C:\Environment\Github\Typora\Java虚拟机\image-20210407163119673.png)

### 对象头Mark Word



![img](C:\Environment\Github\Typora\Java虚拟机\objhead64.png)

![img](C:\Environment\Github\Typora\Java虚拟机\objhead32.png)



## 三、内存溢出

### 内存溢出和内存泄漏

**内存泄漏（memory leak）**：内存泄漏指程序运行过程中分配内存给临时变量，用完之后却没有被GC回收，始终占用着内存，既不能被使用也不能分配给其他程序，于是就发生了内存泄漏。



**内存溢出（out of memory）**：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。



内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。以发生的方式来分类，**内存泄漏可以分为4类：**

1. 常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。
2. 偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。
3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。
4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

**避免内存泄漏的几点建议：**

1. 尽早释放无用对象的引用。
2. 避免在循环中创建对象。
3. 使用字符串处理时避免使用String，应使用StringBuffer。
4. 尽量少使用静态变量，因为静态变量存放在永久代，基本不参与垃圾回收。

### Java堆溢出

堆是存放对象实例的，只要不断创建对象，同时避免垃圾回收机制清除这些对象，就会发生内存溢出异常。

> 使用VM参数设置堆的最小值-Xms参数和堆最大值-Xmx参数，将最大最小设置为一样即可避免堆自动扩展

```java
public class OOM {
    public static void main(String[] args) {
        List<OOM> list = new ArrayList<>();
            while(true){
                OOM oom = new OOM();
                list.add(oom);
            }
    }
}
```

### 虚拟机栈和本地方法栈溢出

>  HotSpot虚拟机不区分虚拟机栈和本地方法栈，使用-Xoss设置本地方法栈大小没有任何效果。
>
> 栈容量只能通过-Xss参数设置

栈溢出有两种异常：

* 如果线程请求的栈深度大于虚拟机运行的最大深度，将抛出StackOverflowError异常，比如递归
* 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常

```java
public class StackOverflowDemo {
    private int length;

    public void StackOverflow(){
        length++;
        StackOverflow();
    }
    public static void main(String[] args) {
        StackOverflowDemo stackOverflowDemo = new StackOverflowDemo();
        try{
            stackOverflowDemo.StackOverflow();
        }catch(Exception e){
            e.printStackTrace();
        }finally {
            System.out.println("栈深度："+stackOverflowDemo.length);
        }
    }
}
```

### 方法区和运行时常量池溢出

方法区存放类加载信息和常量池，可以通过String.intern()方法实现常量池溢出。

>  String.intern()方法是一个本地方法，如果字符串常量池已经包含等于此String对象的字符串，则返回池中该字符串的引用，否则添加此String对象到常量池，并返回此对象的引用。